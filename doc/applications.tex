\section{Applications}

We have successfully used \texttt{z3.rkt} in a number of applications, from
constraint-solving puzzles as illustrated in Section~\ref{sec:interactive}, to
verification and counterexample generation for functional programs. Along the
way, we have been pleasantly surprised by how well the power of Z3 and the
expressiveness of Racket combine. We could not possibly hope to cover all the
uses of an SMT solver, but in this section we discuss a few ideas and starting
points.

\subsection{Quantified Formulas Are Hard}
\label{sec:quantified}

Z3 and other SMT solvers support lists and other recursive types. Z3 only
provides basic support for lists: an \texttt{insert} (cons) operation, a
\texttt{head} operation and a \texttt{tail} operation. Using these, how would
a recursive function that operates over the entire list (say, to calculate its
length) be defined? Z3's macros are substitutions and do not support
recursion, so we must look for alternatives. Our first intuition might be to
use a universal quantifier, as in Section~\ref{sec:derived}. Here is a first
cut at defining a function that calculates the length of an integer list:

\begin{verbatim}
(declare-fun len ((List Int)) Int)
(assert (forall ((xs (List Int)))
  (ite (= xs nil)
       (= (len xs) 0)
       (= (len xs) (+ 1 (len (tail xs)))))))
\end{verbatim}

The problem with this is that solving assertions that use this requires model-
based quantifier instantiation (MBQI)~\cite{mbqi}, which while powerful can
also be quite slow. In our experience it is very easy to write a formula that
Z3's MBQI engine fails to solve in reasonable time. In general, SMT solvers
have a hard time dealing with quantified formulas containing even linear
arithmetic, because there is no sound and complete decision procedure for
them~\cite{halpern91}.

So avoiding quantified formulas altogether seems like a good idea, but how do
we do that? The easiest way is to unroll and bound the recursion to a desired
depth~\cite{sat-recursive}. One way to do this is to define macros
\texttt{len-0}, \texttt{len-1}, \texttt{len-2}, \ldots \texttt{len-N}, where
each \texttt{len-i} returns the length of the list if it is less than or equal
to \texttt{i}, and \texttt{i} if it is greater than it.

\begin{verbatim}
(define-fun len-0 ((xs (List Int)))
  0)

(define-fun len-1 ((xs (List Int)))
  (ite (= xs nil)
       0
       (+ 1 (len-0 (tail xs)))))

(define-fun len-2 ((xs (List Int)))
  (ite (= xs nil)
       0
       (+ 1 (len-1 (tail xs)))))
...
\end{verbatim}

Our system makes defining a series of macros like this a cinch.

\begin{verbatim}
(define (make-length n)
  (smt:define-fun len ((xs (List Int))) Int
    (if (zero? n)
        0
        (ite/s (=/s xs nil/s)
               0
               (let ([sublen (make-length (sub1 n))])
                 (+/s 1 (sublen (tail/s xs)))))))
  len)
\end{verbatim}

\texttt{(make-length 5)} returns an SMT function that works for lists of up to
length 5, and returns 5 for anything bigger than that. Note how freely the
Racket \texttt{if} and \texttt{let} forms are mixed into the SMT body. These
constructs are evaluated at definition time, meaning that this definition
reduces to the series of macros defined above, except much more
concisely\footnote{In some applications it might be useful to start with
functions that handle small lists and then work our way up as Z3 keeps proving
facts for bigger and bigger list lengths. Such cases can be implemented by
incrementally adding macros to handle bigger lengths.}

It is easy to define bounded recursive functions along the same lines that
reverse lists, concatenate them, and filter them on a predicate.

\subsection{Verifying Recursive Functions}

Using these building blocks we can now start verifying properties for
recursive functions. For this section we will work with a simple but
non-trivial example:~\textit{quicksort}. A simple functional
implementation of quicksort might look like the following:

\begin{verbatim}
(define (qsort lst)
  (if (null? lst)
      null
      (let*
       ([pivot (car lst)]
        [rest (cdr lst)]
        [left (qsort (filter (lambda (x) (<= x pivot)) rest))]
        [right (qsort (filter (lambda (x) (> x pivot)) rest))])
        (append left (cons pivot right))))
\end{verbatim}

This definition is correct, but what if the programmer mistakenly types in
\texttt{<} instead of \texttt{<=}, or perhaps uses \texttt{>=} instead of
\texttt{>}? We note that in both cases the length of the output list will be
different from that of the input list whenever a pivot is repeated in the rest
of the list, so that seems like a good property to verify.

Using the method discussed in Section~\ref{sec:quantified}, we can rewrite
\texttt{qsort} as a bounded recursive function. Assuming we have \texttt
{make-qsort}, we can now verify the length property for all lists up to a
certain length $n$.

\begin{verbatim}
(smt:with-context
 (smt:new-context)
 (define qsort (make-qsort n))
 ; adding 1 to the maximum length is enough to show inequality
 (define len (make-length (add1 n)))
 (smt:declare-fun xs () (List Int))
 ; set a bound on the length
 (smt:assert (<=/s (len xs) n))
 ; prove the length property by asserting its negation
 (smt:assert (not/s (=/s (len xs) (len (qsort xs)))))
 (smt:check-sat))
\end{verbatim}

Proving a property is done by checking that its negation is unsatisfiable. A
quicksort works \textit{correctly} for lists up to length $n$ iff the above
code returns \texttt{'unsat}. For quicksorts that are buggy (\texttt{'sat}),
we can find a counterexample using \texttt{(smt:eval xs)} and
\texttt{(smt:eval (qsort xs))} as before. For $n=4$ on a buggy quicksort with
filters \texttt{<=} and \texttt{>=}, Z3 returned us the counterexample with
input \texttt{'(-3 -2 -1 -2)}, which as expected contains a repeated element.

There is nothing special about quicksort \textit{per se}: we expect this
approach to easily generalise to other functions that operate on lists and
other data structures, and to be able to prove more complex properties, such
as whether a given sorting algorithm is stable.
