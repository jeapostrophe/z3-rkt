\begin{abstract}
 We present a system that integrates Z3 SMT solver with
 Racket programming language. The system defines a programmer's
 interface in Racket that makes it easy to harness the power
 of Z3 to discover solutions to logical constraints. The
 interface format, although in Racket, retains the structure
 and brevity of SMT-LIB format, thereby making it trivial to
 translate SMT-LIB programs to it. The integration of Z3
 with Racket is useful for many applications like debugging,
 program verification, and automatic test generation. We
 provide some examples of the proposed usages.
\end{abstract}
\section{Introduction}
We present a system that integrates Z3 SMT solver~\cite{z3} with
Racket programming language~\cite{racket}. The integrated
system allows the user to embed logical constraints in a
Racket program, thus assisting in program verification,
debugging, automatic test generation and related
applications.

\subsection{Why z3.rkt? A Motivating Example}

SMT solvers today are powerful tools that can make and can solve a wide variety
of problems using efficient heuristics. Problems they can attack range from
simple puzzles like Sudoku and n-queens, to planning and scheduling, program
analysis~\cite{Gulwani:08}, whitebox fuzz testing~\cite{Godefroid:08} and
bounded model checking~\cite{Armando:09}.

Yet, SMT solvers are only used by a small number of experts. It isn't hard to
see why: the standard way for programs to interact with SMT solvers like
Z3~\cite{z3}, Yices~\cite{yices} and CVC3~\cite{cvc3} is via powerful but
relatively arcane C APIs. For example, here's a C program that asks Z3 whether
the simple proposition $p \wedge \neg p$ is satisfiable.

\begin{verbatim}
Z3_config cfg = Z3_mk_config();
Z3_context ctx = Z3_mk_context(cfg);
Z3_del_config(cfg);
Z3_sort bool_sort = Z3_mk_bool_sort(ctx);

Z3_symbol symbol_p = Z3_mk_int_symbol(ctx, 0);

Z3_ast p = Z3_mk_const(ctx, symbol_p, bool_sort);
Z3_ast not_p = Z3_mk_not(ctx, p);

Z3_ast args[2] = {p, not_p};
Z3_ast conjecture = Z3_mk_and(ctx, 2, args);

Z3_assert_cnstr(ctx, conjecture);

Z3_lbool sat = Z3_check(ctx);

Z3_del_context(ctx);
return sat;
\end{verbatim}

Simultaneously, most SMT solvers also feature interaction via the standard input
language SMT-LIB~\cite{smtlib2:10}. SMT-LIB is \textit{significantly} easier to
use in isolation. The same program as above in SMT-LIB would look something like

\begin{verbatim}
(declare-fun p () Bool)
(assert (and p (not p)))
(check-sat)
\end{verbatim}

However, the SMT-LIB interfaces are generally hard to use directly from C
programs and often not as full-featured\footnote{Z3, for instance, supports
  plugging in external theories via the C API, but not via the textual SMT-LIB
  interface.}  or extensible. Importantly, it is difficult to write programs
that \textit{interact} dynamically with the solver in some way, for example by
adding assertions based on generated models, and therefore it is often difficult
to build new abstractions on top.

Faced with these difficulties, we decided to reimplement SMT-LIB in a way that
allowed for the same power as the C version while appearing naturally integrated
into the language. Since SMT-LIB is s-expression-based, a Lisp seemed like a
natural choice for an implementation. Our implementation is in
Racket~\cite{racket}, a descendant of Scheme, because of its extensive
facilities for implementing new languages~\cite{Tobin-Hochstadt:11}, not just
for the interface to the solver, but also for the resulting program analysis
tools that the solver would make possible.

Using this system, the program above becomes almost as brief as the SMT-LIB
version.

\begin{verbatim}
(smt:with-context
 (smt:new-context-info)
 (smt:declare-fun p () Bool)
 (smt:assert (and p (not p)))
 (smt:check-sat))
\end{verbatim}

\subsection{Sudoku}

We now turn our attention to a problem that demonstrates how this interactivity
is useful. A Sudoku puzzle asks the player to complete a partially pre-filled
9$\times$9 grid with the numbers 1 through 9 such that no row, column, or
3$\times$3 box has two instances of a number. This is a classic constraint
satisfaction problem, and any constraint solver can handle it with ease.

A Racket program using \texttt{z3.rkt} to solve Sudoku would look something like

\begin{verbatim}
(define (solve-sudoku grid)
  (smt:with-context
   (smt:new-context-info)
   ;; Declare a scalar datatype (finite domain type) with 9 entries
   (smt:declare-datatypes () ((Sudoku S1 S2 S3 S4 S5 S6 S7 S8 S9)))
   ;; Represent the grid as an array from integers to the Sudoku type.
   (smt:declare-fun sudoku-grid () (Array Int Sudoku))
   ;; Assert the standard grid rules (row, column, box)
   (add-sudoku-grid-rules)
   ;; Add pre-filled entries
   (add-grid grid)
   (define sat (smt:check-sat))
   ;; 'sat means we found a solution, 'unsat means we didn't
   (if (eq? sat 'sat)
       ;; Retrieve the values from the model
       (for/list ([x (in-range 0 81)])
         (smt:eval (select sudoku-grid ,x)))
       #f)))
\end{verbatim}

Here we omit a couple of function definitions: \texttt{add-sudoku-grid-rules}
asserts the standard Sudoku grid rules, and \texttt{add-grid} reads the grid in
a particular format and creates assertions based on the grid. We note that the
SMT-LIB function \texttt{(select arr x)} retrieves the value at \texttt{x} from
the array \texttt{arr}, and that this can be used to add constraints on the
array (for instance, \texttt{(assert (= (select arr x) y))}).

However, simply finding a solution isn't enough for a good Sudoku solver: it
must also verify that there aren't any other solutions. The usual way to do that
for a constraint solver is by retrieving a generated model, adding assertions
such that this model cannot be generated, and then asking the solver whether the
system of assertions is still satisfiable. If they are, a second solution
exists and the puzzle is considered invalid.

This is where the interactivity offered by \texttt{z3.rkt} becomes useful, since
it lets the programmer add assertions on the fly. The last part of the program
then becomes

\begin{verbatim}
   ...
   (if (eq? sat 'sat)
       ;; Make sure no other solution exists
       (let ([result-grid
         (for/list ([x (in-range 0 81)])
           (smt:eval (select sudoku-grid ,x)))])
         (smt:assert
          (not (and
                ,@(for/list ([(x i) (in-indexed result-grid)])
                    `(= (select sudoku-grid ,i) ,x)))))
         (if (eq? (smt:check-sat) 'sat)
             #f ; Multiple solutions
             result-grid))
       #f)))
\end{verbatim}



\subsection{Organization}
