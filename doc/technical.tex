\section{Design and Implementation}

\texttt{z3.rkt} is currently implemented as a few hundred lines of Racket code
that interface with the Z3 engine via the provided library.

\textbf{The Z3 wrapper.} We use Racket's foreign interface \cite{racket/foreign}
to map the Z3 library's C functions into Racket. The programmer interface
communicates with Z3 by calling the Racket functions defined by the
wrapper. While it is possible to use the Z3 wrapper directly, we highly
recommend using the programmer interface instead.

\textbf{The programmer interface.} This is a small set of Racket macros and
functions layered on top of the Z3 wrapper. The aim of the interface is to hide
the complexities of the C wrapper and stay as close to the SMT-LIB v2 standard
\cite{smtlib2:10} as possible, so that newcomers familiar with the standard can
start using the system quickly. For instance, here is a simple SMT-LIB program
that checks whether a contradiction is satisfiable.

\begin{verbatim}
(declare-fun p () Bool)
(assert (and p (not p)))
(check-sat)
\end{verbatim}

This program would be written in \texttt{z3.rkt} as

\begin{verbatim}
(smt:with-context
 (smt:new-context-info)
 (smt:declare-fun p () Bool)
 (smt:assert (and p (not p)))
 (smt:check-sat))
\end{verbatim}

The same program using the C wrapper directly (or in C itself!) would involve a
large number of function calls to first create the variable involved and then
the contradiction.

Since SMT-LIB v2 and Racket are both s-expression based, we reuse Racket's own
parser to parse SMT-LIB expressions.

The true power of the system, however, is in the integration it makes possible
with Racket code. SMT-LIB v2 assertions that would either have to be tediously
written by hand or generated by another program can now be written concisely
using Racket's iteration and sequencing constructs.
