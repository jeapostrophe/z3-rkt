\section{Design and Implementation}

\texttt{z3.rkt} is currently implemented as a few hundred lines of Racket code
that interface with the Z3 engine via the provided library. Since the system is
still a work in progress, some of these details might change in the future.

\textbf{The Z3 wrapper.} We use Racket's foreign interface \cite{racket/foreign}
to map the Z3 library's C functions into Racket. The programmer interface
communicates with Z3 by calling the Racket functions defined by the
wrapper. While it is possible to use the Z3 wrapper directly, we highly
recommend using the programmer interface instead.

\textbf{The programmer interface.} This is a small set of Racket macros and
functions layered on top of the Z3 wrapper. The aim of the interface is to hide
the complexities of the C wrapper and stay as close to the SMT-LIB v2 standard
\cite{smtlib2:10} as possible, so that newcomers familiar with the standard can
start using the system quickly. For instance, here is a simple SMT-LIB program
that checks whether a contradiction is satisfiable.

\begin{verbatim}
(declare-fun p () Bool)
(assert (and p (not p)))
(check-sat)
\end{verbatim}

This program would be written in \texttt{z3.rkt} as

\begin{verbatim}
(smt:with-context
 (smt:new-context-info)
 (smt:declare-fun p () Bool)
 (smt:assert (and p (not p)))
 (smt:check-sat))
\end{verbatim}

The same program using the C wrapper directly (or in C itself!) would involve a
large number of function calls --- first to create the variable involved, and
then the contradiction.

The true power of the system, however, is in the integration it makes possible
with Racket code. Programs using an SMT solver often need to dynamically add or
change assertions depending on the model the SMT solver generates. The
recreational game of Sudoku is a good example: a Sudoku solver needs to check if
a particular grid has multiple solutions. The straightforward way to do that is
to first ask the SMT solver for a solution (model), then add assertions negating
the generated solution and ask if the solver can come up with another
model. With a standard SMT-LIB program, there's no way to do that short of
generating a brand new program containing the negation of the first solution,
then asking the solver to solve the problem all over again. This gets wasteful
as the process is iterated further, say to get all possible solution grids for a
particular Sudoku grid. With the present system, however, we can simply evaluate
the model and add assertions on the fly by calling the respective C functions.

Thus we note that the SMT-LIB v2 interface is concise but not interactive, while
the C interface is the opposite. \texttt{z3.rkt} is the best of both worlds: you
get the full power of the C interface, combined with the ease of use of the
SMT-LIB v2 interface.
