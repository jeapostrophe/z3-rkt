\section{Design and Implementation}
\label{sec:design-impl}

\texttt{z3.rkt} is currently implemented as a few hundred lines of Racket code
that interface with the Z3 engine via the provided library. Since the system is
still a work in progress, some of these details might change in the future.

\textbf{The Z3 wrapper.} We use Racket's foreign interface \cite{racket/foreign}
to map the Z3 library's C functions into Racket. The programmer interface
communicates with Z3 by calling the Racket functions defined by the
wrapper. While it is possible to use the Z3 wrapper directly, we highly
recommend using the programmer interface instead.

\textbf{The core commands.} This is a small set of Racket macros and functions
layered on top of the Z3 wrapper. As noted in Section~\ref{sec:motiv}, the aim
here is to hide the complexities of the C wrapper and stay as close to SMT-LIB
version 2 commands \cite{smtlib2:10} as possible. We prefix commands with
\texttt{smt:} to avoid collision issues.

\textbf{Built-in functions.} Z3 comes with a number of built-in functions that
operate on booleans, numbers, and more complex values. We expose these
functions directly but add a \texttt{/s} suffix to their usual names in the
SMT-LIB standard, because most SMT-LIB names are already defined as functions
by Racket and we want to avoid colliding with them.

\textbf{Derived abstractions.} Since the full power of Racket is available to
us, we can define abstractions on top that allow consumers to simplify their
code. For example, SMT-LIB allows users to define macros via the \texttt
{define-fun} command.

\begin{verbatim}
(define-fun max ((a Int) (b Int)) Int
  (ite (> a b) a b))
...
(assert (= (max 4 7) 7))
\end{verbatim}

However, Z3's API exposes no such command. One's first thought might be to
define a Racket function to do the same thing:

\begin{verbatim}
(define (smt-max a b)
  (ite/s (>/s a b) a b))
...
(smt:assert (=/s (smt-max 4 7) 7))
\end{verbatim}

This works for smaller macros, but in our experience this na\"{i}ve
substitution can result in final expressions becoming too large for deeply
nested recursive functions.

We note, however, that any macro can also be written as a universally
quantified formula. For example, \texttt{max} can be rewritten in the
following way.

\begin{verbatim}
(declare-fun max (Int Int) Int)
(assert (forall ((a Int) (b Int))
                (= (max a b)
                   (ite (> a b) a b))))
\end{verbatim}

We can thus provide a Racket macro \texttt{smt:define-fun} that has the same
syntax as the SMT-LIB \texttt{define-fun} and that performs precisely this
transformation.

\subsection{Porting existing SMT-LIB code}
\label{sec:porting-smt-lib}

One of our explicit goals is to enable existing SMT-LIB version 2 code to be
ported with minimal mechanical changes. Table~\ref{table:smt-}
