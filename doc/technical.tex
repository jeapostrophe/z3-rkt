\section{Design and Implementation}

\texttt{z3.rkt} is currently implemented as a few hundred lines of Racket code
that interface with the Z3 engine via the provided library. Since the system is
still a work in progress, some of these details might change in the future.

\textbf{The Z3 wrapper.} We use Racket's foreign interface \cite{racket/foreign}
to map the Z3 library's C functions into Racket. The programmer interface
communicates with Z3 by calling the Racket functions defined by the
wrapper. While it is possible to use the Z3 wrapper directly, we highly
recommend using the programmer interface instead.

\textbf{The programmer interface.} This is a small set of Racket macros and
functions layered on top of the Z3 wrapper. The aim of the interface is to hide
the complexities of the C wrapper and stay as close to the SMT-LIB v2 standard
\cite{smtlib2:10} as possible, so that newcomers familiar with the standard can
start using the system quickly. For instance, here is a simple SMT-LIB program
that checks whether a contradiction is satisfiable.

\begin{verbatim}
(declare-fun p () Bool)
(assert (and p (not p)))
(check-sat)
\end{verbatim}

\texttt{z3.rkt} retains the structure and brevity of the SMT-LIB program.

\begin{verbatim}
(smt:with-context
 (smt:new-context-info)
 (smt:declare-fun p () Bool)
 (smt:assert (and p (not p)))
 (smt:check-sat))
\end{verbatim}

On the other hand, the same program becomes significantly more verbose in C.

\begin{verbatim}
Z3_config cfg = Z3_mk_config();
Z3_context ctx = Z3_mk_context(cfg);
Z3_del_config();
Z3_sort bool_sort = Z3_mk_bool_sort(ctx);

Z3_symbol symbol_p = Z3_mk_int_symbol(ctx, 0);

Z3_ast p = Z3_mk_const(ctx, symbol_p, bool_sort);
Z3_ast not_p = Z3_mk_not(ctx, p);

Z3_ast args[2] = {p, not_p};
Z3_ast conjecture = Z3_mk_or(ctx, 2, args);

Z3_assert_cnstr(ctx, conjecture);
return Z3_check(ctx);
\end{verbatim}

The true power of the system, however, is in the integration it makes possible
with Racket code. Programs using an SMT solver often need to dynamically add or
change assertions depending on the model the SMT solver generates. The
recreational game of Sudoku is a good example: a Sudoku solver needs to check if
a particular grid has multiple solutions. The straightforward way to do that is
to first ask the SMT solver for a solution (model), then add assertions negating
the generated solution and ask if the solver can come up with another
model. With a standard SMT-LIB program, there's no way to do that short of
generating a brand new program containing the negation of the first solution,
then asking the solver to solve the problem all over again. This gets wasteful
as the process is iterated further, say to get all possible solution grids for a
particular Sudoku grid. With the present system, however, we can simply evaluate
the model and add assertions on the fly by calling the respective C functions.

Thus the SMT-LIB v2 interface is concise but not interactive, while the C
interface is the opposite. \texttt{z3.rkt} is the best of both worlds: you get
the full power of the C interface combined with the ease of use of the SMT-LIB
v2 interface.
